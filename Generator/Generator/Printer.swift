//
//  Printer.swift
//  Generator
//
//  Created by Miguel de Icaza on 4/19/23.
//

import Foundation

class Printer {
    let name: String
    // Where we accumulate our output for the p/b routines
    var result = ""
    var indentStr = ""          // The current indentation string, based on `indent`
    var indent = 0 {
        didSet {
            indentStr = String (repeating: "    ", count: indent)
        }
    }
    
    fileprivate init(name: String) {
        self.name = name
    }

    func preamble () {
        p("""
        // This file is autogenerated, do not edit
        @_implementationOnly import GDExtension
        
        #if CUSTOM_BUILTIN_IMPLEMENTATIONS
        #if canImport(Darwin)
        import Darwin
        #elseif os(Windows)
        import ucrt
        import WinSDK
        #elseif canImport(Glibc)
        import Glibc
        #elseif canImport(Musl)
        import Musl
        #else
        #error("Unable to identify your C library.")
        #endif
        #endif
        """)

    }
    
    // Prints the string, indenting any newlines with the current indentation
    func p (_ str: String) {
        for x in str.split(separator: "\n", omittingEmptySubsequences: false) {
            print ("\(indentStr)\(x)", to: &result)
        }
    }
    
    func `if`(_ `if`: String, then: () -> Void, else: () -> Void) {
        p("if \(`if`) {")
        indent += 1
        then()
        indent -= 1
        p("} else {")
        indent += 1
        `else`()
        indent -= 1
        p("}")
    }
    
    // Prints a variable definition
    func staticVar (visibility: String = "", name: String, type: String, block: () -> ()) {
        if generateResettableCache {
            p ("fileprivate static var _c_\(name): \(type)? = nil")
            p ("fileprivate static var _g_\(name): UInt16 = 0")
            b ("\(visibility)static var \(name): \(type) ") {
                self ("if _g_\(name) == swiftGodotLibraryGeneration") {
                    self ("if let _c_\(name)") {
                        self ("return _c_\(name)")
                    }
                }
                p ("_g_\(name) = swiftGodotLibraryGeneration")
                self ("func load () -> \(type)") {
                    block ()
                }
                self ("let ret = load ()")
                self ("_c_\(name) = ret")
                self ("return ret")
            }
        } else {
            b ("\(visibility)static var \(name): \(type) =", suffix: "()", block: block)
        }
    }

    /// Emit conditional compilation directives and a Swift cover implementation, if there is a Swift cover implementation.
    ///
    /// If there is a cover for `key`, I emit an `#if ... #else ... #endif` structure which compiles `cover` when `CUSTOM_BUILTIN_IMPLEMENTATIONS` is set, and compiles the output of `otherwise` when `CUSTOM_BUILTIN_IMPLEMENTATIONS` is not set.
    ///
    /// If there is no cover for `key`, I just emit `otherwise()`.
    func useSwiftCoverIfAvailable(for key: SwiftCovers.Key, otherwise: () -> ()) {
        if let cover = swiftCovers.covers[key] {
#if TESTABLE_SWIFT_COVERS
            self.if("useSwiftCovers") {
                p(cover)
            } else: {
                otherwise()
            }
#else
            p ("#if CUSTOM_BUILTIN_IMPLEMENTATIONS")
            p(cover)
            p ("#else // CUSTOM_BUILTIN_IMPLEMENTATIONS")
            otherwise()
            p ("#endif // CUSTOM_BUILTIN_IMPLEMENTATIONS\n")
#endif
        } else {
            otherwise()
        }
    }

    // Prints a block, automatically indents the code in the closure
    func b (_ str: String, arg: String? = nil, suffix: String = "", block: () -> ()) {
        p (str + " {" + (arg ?? ""))
        indent += 1
        let saved = indent
        block ()
        if indent != saved {
            print ("Indentation out of sync, the nested block messed with indentation")
        }
        indent -= 1
        p ("}\(suffix)\n")
    }

    func callAsFunction(_ str: String) {
        p (str)
    }
    
    func callAsFunction(_ str: String, arg: String? = nil, suffix: String = "", block: () -> ()) {
        b (str, arg: arg, suffix: suffix, block: block)
    }
    
    func save (_ file: String) {
        if let existing = try? String (contentsOfFile: file) {
            if existing == result {
                return
            }
        }
        try! result.write(toFile: file, atomically: false, encoding: .utf8)
    }
}

actor PrinterFactory {
    static let shared = PrinterFactory()
    
    private var printers: [Printer] = []
    
    func initPrinter(_ name: String) -> Printer {
        let printer = Printer(name: name)
        printers.append(printer)
        return printer
    }
    
    func save (_ file: String) {
        let result = printers.sorted(by: { $0.name < $1.name }).map({ $0.result }).joined(separator: "\n")
        if let existingData = try? Data(url: URL(fileURLWithPath: file)), let existing = String(data: existingData, encoding: .utf8) {
            if existing == result {
                return
            }
        }
        try! result.write(toFile: file, atomically: false, encoding: .utf8)
    }
}
